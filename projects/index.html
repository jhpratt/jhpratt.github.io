<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Projects | jhpratt.dev</title><link href="https://jhpratt.dev/base.css?h=36dfebf3460d1751bd49" rel=stylesheet><link href="https://jhpratt.dev/jhp.svg?h=d5ad3c9b46fe1dc5c0a3" rel=icon type=image/svg+xml><body><nav><a href=https://jhpratt.dev/>Home</a><a href=https://jhpratt.dev/projects/>Projects</a><a href=https://jhpratt.dev/talks/>Talks</a><a href=https://jhpratt.dev/contributions/>Contributions</a><a href=https://jhpratt.dev/contact/>Contact</a></nav><main><h1 id=projects>Projects<a aria-label="Anchor link for: projects" class=anchor href=#projects tabindex=-1>ðŸ”—</a></h1><h2 id=time><code>time</code><a aria-label="Anchor link for: time" class=anchor href=#time tabindex=-1>ðŸ”—</a></h2><p>In September 2019, I requested to take over the unmaintained <code>time</code> in Rust. As anyone that has ever worked with time can attest to, this is no small feat. By December, I had released the first major release in over six years. As a foundational crate in the Rust ecosystem, time is used by a significant portion of the Rust ecosystem.<p>The revamped <code>time</code> includes extensive documentation and nearly 100% test coverage. Macros are provided to allow for compile-time verification of certain data, avoiding unnecessary runtime costs. Formatting and parsing is done via a more readable syntax, and is significantly more extensible than the implementations in other crates. The crate is also fully <code>#![no_std]</code> compatible, allowing it to be used in embedded environments. <code>time</code> is fully interoperable with the standard library's types, allowing for easy conversion and direct use with one another.<p>During my maintenance of <code>time</code>, I have focused on providing a stable, reliable crate that has the features that users need. Compile time is important, so there are many feature flags to limit the number of dependencies compiled to only those needed by the user. However, runtime is also important, which is why I have spent a fair amount of effort on optimization. As an example, I adapted a well-known algorithm to better suit the internal data format, improving performance by 70% in some cases.<h2 id=num-threads><code>num_threads</code><a aria-label="Anchor link for: num-threads" class=anchor href=#num-threads tabindex=-1>ðŸ”—</a></h2><p>The <code>num_threads</code> Rust crate lets you determine the number of threads that are part of the running process. This is useful for determining the number of threads currently in use as part of a thread pool, for example. This crate was originally part of <code>time</code>, but was split out as it can be useful for other users. In <code>time</code>, is it used to determine if certain methods can be soundly called.<h2 id=standback><code>standback</code><a aria-label="Anchor link for: standback" class=anchor href=#standback tabindex=-1>ðŸ”—</a></h2><p>During development of <code>time</code>, I frequently found myself writing shims to allow the use of recently-stabilized APIs on older compilers. However, it was necessary to use <code>.rem_euclid_shim()</code> instead of <code>.rem_euclid()</code> to avoid name collisions on newer compilers.<p>As it turned out, it's not too difficult to bring code from Rust's standard library to the <code>standback</code> Rust crate, allowing the use on older compilers. By gating and aliasing to <code>std</code> (or <code>core</code> as appropriate), it was possible to avoid this. This turns out to be incredibly useful as a standalone crate; it allows others to use newer APIs with near-zero effort: just a single line of code per file for most use cases.<p>Unfortunately, <code>time</code> was the only crate that made use of <code>standback</code>, so maintenance ceased after Rust's 1.60.0 release, as <code>time</code> migrated away from it to reduce compile times.<h2 id=deranged><code>deranged</code><a aria-label="Anchor link for: deranged" class=anchor href=#deranged tabindex=-1>ðŸ”—</a></h2><p><code>deranged</code> is a proof-of-concept Rust crate for range-bound integers. It is intended to serve as a proving ground for a future RFC to add this functionality to Rust itself. It supports a large number of methods present on primitive integers, and will support arithmetic traits when <code>rustc</code> supports the necessary language features on stable.</main>